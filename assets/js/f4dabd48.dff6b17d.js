"use strict";(self.webpackChunkexamples_classic=self.webpackChunkexamples_classic||[]).push([[2331],{3905:(e,t,n)=>{n.d(t,{Zo:()=>l,kt:()=>u});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),d=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},l=function(e){var t=d(e.components);return a.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,c=e.parentName,l=i(e,["components","mdxType","originalType","parentName"]),h=d(n),u=r,f=h["".concat(c,".").concat(u)]||h[u]||p[u]||s;return n?a.createElement(f,o(o({ref:t},l),{},{components:n})):a.createElement(f,o({ref:t},l))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,o=new Array(s);o[0]=h;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:r,o[1]=i;for(var d=2;d<s;d++)o[d]=n[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},6248:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>o,default:()=>l,frontMatter:()=>s,metadata:()=>i,toc:()=>c});var a=n(7462),r=(n(7294),n(3905));const s={sidebar_position:3},o="Back-Backend",i={unversionedId:"backend/back-backend",id:"backend/back-backend",isDocsHomePage:!1,title:"Back-Backend",description:"The back-backend which contains the Node-Red part and the API accesible through the backend or the front of the system.",source:"@site/docs/backend/back-backend.md",sourceDirName:"backend",slug:"/backend/back-backend",permalink:"/wimp-wiki/docs/backend/back-backend",editUrl:"https://github.com/facebook/docusaurus/edit/main/website/docs/backend/back-backend.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Node-RED",permalink:"/wimp-wiki/docs/backend/node-red"},next:{title:"Front-Backend",permalink:"/wimp-wiki/docs/backend/front-backend"}},c=[{value:"Node-RED",id:"node-red",children:[{value:"Security of the Node-RED web interface",id:"security-of-the-node-red-web-interface",children:[]},{value:"Security of the Node-RED API",id:"security-of-the-node-red-api",children:[]}]},{value:"Receive request",id:"receive-request",children:[]}],d={toc:c};function l(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"back-backend"},"Back-Backend"),(0,r.kt)("p",null,"The back-backend which contains the Node-Red part and the API accesible through the backend or the front of the system."),(0,r.kt)("p",null,"Each time a student wants to access the status of his teachers, the frontend server sends a request to the express api.\nExpress. Express will check this request and then interogate Node-RED with a GET in order to notify the different states of the professor. Finally Express will transform the raw information received by Node-RED (as 'int', for example) and return clean information (as 'not available')."),(0,r.kt)("h2",{id:"node-red"},"Node-RED"),(0,r.kt)("p",null,"Node-RED is embedded in the Express server. That is to say that it plays the role of an API. However Node-RED will be launched as a classical server except that all requests will go through the Express server.\nThe Express server will make requests to ",(0,r.kt)("inlineCode",{parentName:"p"},"/node")," to acces the Node-RED server."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'// Node-RED config\nvar settings = {\n    httpAdminRoot:"/red", // base url to access the Node-RED web interface\n    httpNodeRoot: "/node", // base url to access endpoints in the flows\n    userDir: path.resolve("../flows/"),\n    flowFile:\'flows.json\',\n    editorTheme: {\n        tours: false, // To disable the welcome tour\n    },\n    functionGlobalContext: { }    // enables global context\n};\n\nRED.init(server, settings);\napp.use(settings.httpNodeRoot, nodeRedAccess, RED.httpNode);\napp.use(settings.httpAdminRoot, checkAuthenticated, nodeRedAuthentication, RED.httpAdmin);\n...\n\nRED.start();\n')),(0,r.kt)("p",null,"This configuration allows to access the Node-RED web interface through the ",(0,r.kt)("inlineCode",{parentName:"p"},"/red")," and access the Node-RED API through the ",(0,r.kt)("inlineCode",{parentName:"p"},"/node"),"."),(0,r.kt)("p",null,"To learn more about Node-RED, please see this ",(0,r.kt)("a",{parentName:"p",href:"/wimp-wiki/docs/backend/node-red"},"page"),"."),(0,r.kt)("h3",{id:"security-of-the-node-red-web-interface"},"Security of the Node-RED web interface"),(0,r.kt)("p",null,"In order to secure the access to the Node-RED web interface, we decided to use a succession of two middlewares. The first middleware ",(0,r.kt)("inlineCode",{parentName:"p"},"checkAuthenticated")," allows to check if the user that wants to access the interface is authenticated and have a valid session on the server side. The second middleware ",(0,r.kt)("inlineCode",{parentName:"p"},"nodeRedAuthentication"),' while update the request with the "credentials" to access to the web interface as an anonymous user.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'nodeRedAuthentication = (req, res, next) => {\n    if (req.isAuthenticated()) {\n        req.user = {\n            "anonymous":true,\n            "permissions": "*"\n        }\n    }\n    return next();\n}\n')),(0,r.kt)("h3",{id:"security-of-the-node-red-api"},"Security of the Node-RED API"),(0,r.kt)("p",null,"In order to secure the access to the Node-RED API, we decided to develop a custom middleware. Indeed, we needed a middleware that can adapt depending on the endpoint that is requested because we need to distinguish two types of request to the Node-RED API:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The requests that come from the backend Express server himself"),(0,r.kt)("li",{parentName:"ul"},"The requests that come from external IoT devices which want to send data")),(0,r.kt)("p",null,"Here is the code of the middleware that we developed:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'nodeRedAccess = (req, res, next) => {\n    const endpoints = config.EXTERNAL_DEVICES_ROUTES.split(\',\');\n    console.log("Node-RED Security check for " + req.originalUrl + "...");\n\n    if (endpoints.includes(req.originalUrl)) {\n        console.log(\'\\x1b[32m%s\\x1b[0m\', "Node-RED Security Exception Accepted for " + req.originalUrl);\n        return next();\n    }\n    \n    const backendRestrictedAccess = config.BACKEND_RESTRICTED_ACCESS.split(\',\');\n    if (backendRestrictedAccess.includes(req.originalUrl)) {\n        try {\n            if (bcrypt.compareSync(req.body.password, config.NODE_RED_SECRET_ENC)) {\n                console.log(\'\\x1b[32m%s\\x1b[0m\', "Backend restricted access for " + req.originalUrl);\n                req.body = {};\n                return next();\n            };\n        } catch (e) {\n            console.log(e);\n        }\n    }\n    \n    console.log(\'\\x1b[31m%s\\x1b[0m\', "Node-RED Security Exception Rejected for " + req.originalUrl);\n    res.redirect("/login");\n}\n')),(0,r.kt)("p",null,"Thanks to this custom middleware, we can create security exceptions for the external IoT devices that want to send their data while authorizating only the requests that come from the backend himself. All the others request are rejected and redirected to the login page. "),(0,r.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"For the requests that come from the backend himself and that have a target which is Node-RED API endpoint, they must be of POST type and have a body of this type:\n",(0,r.kt)("inlineCode",{parentName:"p"},'{\n    "password": "**Node-RED API Secret**"\n}')," "))),(0,r.kt)("h2",{id:"receive-request"},"Receive request"),(0,r.kt)("p",null,"All the API routes are in the ",(0,r.kt)("inlineCode",{parentName:"p"},"/modules/apiRouter.js")),(0,r.kt)("p",null,"The frontend webserver call a POST on /states to get the states while providing the right password to get an access to the backend API and make sure that the request comes from an authorized web server."),(0,r.kt)("p",null,"The program will browse the entire database where the teachers are stored.\nIt will create a profile for each teacher containing the information that will be sent as a response. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'...\nconst db_staff = new JSONdb(\'./database/staff.json\');\n    let staff = {};\n    let states = [];\n    try{\n        staff = db_staff.JSON();\n        Object.keys(staff).forEach(e => {\n            const person = staff[e];\n            let state = {\n                id: e,\n                pp: "",\n                firstNameRaw: person.firstName,\n                firstName: "",\n                lastName: person.lastName,\n                building: person.building,\n                department: person.department,\n                office: person.office,\n                statusColor: "",\n                statusMsg: "",\n                defaultMsg: "",\n                currentState: "",\n                visibility: {}\n            }\n    ...\n')),(0,r.kt)("p",null,"Finally, the program will fill in the relevant fields through a series of processes and then store the profile in a list that will be sent as a response.\nThe most important part is when the server calls Node-RED to get the teacher's availability status. To do this the server makes an http request to Node-RED (which is actually implemented as an internet API to the server)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'try {\n    ...\n        // Find if the person is in the database\n        if (fs.existsSync(path.resolve(\'./pp/\' + person.pp))) {\n            state.pp = e;\n        } else {\n            state.pp = "undefined";\n        }\n\n        // Reduce first name\n        if(person.firstName.includes(" ")){\n            fn = person.firstName.split(\' \')\n            fn = fn.reduce((a,aa)=>{return (  a + "." + aa[0]) },"");\n            state.firstName = fn.slice(1);\n        } else {\n            state.firstName = person.firstName;\n        }\n        // check if the professor is on mode "tracking off"\n        if (person.tracking === "OFF") {\n            state.statusColor = "grey";\n            state.statusMsg = "Disconnected";\n        } else {\n\n            // Find if the current state is defined <----\n            const db_data = new JSONdb(path.resolve(\'./database/db.json\'));\n            let currentState = "undefined";\n            if (db_data.has(e)){\n                currentState = db_data.get(e);\n            }\n            state.currentState = currentState;\n            \n            // Find the color & msg of the state \n            if(currentState !== "undefined"){\n                state.visibility = person.states[currentState].visibility;\n                state.statusColor = person.states[currentState].color;\n                state.statusMsg = person.states[currentState].msg;\n                switch (state.statusColor) {\n                    case "green":\n                        state.defaultMsg = person.default.available;\n                        break;\n                    case "orange":\n                        state.defaultMsg = person.default.busy;\n                        break;\n                    case "red":\n                        state.defaultMsg = person.default.unavailable;\n                        break;\n                }\n            }\n            else {\n                state.statusColor = "grey";\n                state.statusMsg = "undefined";\n            }\n        }\n        states.push(state);\n    })\n}\ncatch (e) {\n    console.log(e);   \n}\nres.send(states).status(200);\n')))}l.isMDXComponent=!0}}]);